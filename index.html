<!DOCTYPE html>
<html lang="zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Nano">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Nano">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Haopeng Wu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh_CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Nano</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Nano</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Haopeng Wu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/29/c++/gtest%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/29/c++/gtest%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">gtest进阶</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-04-29 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-29T00:00:00+00:00">2025-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gtest进阶"><a href="#gtest进阶" class="headerlink" title="gtest进阶"></a>gtest进阶</h1><p>本文记录了一些冷门但可能很重要的 gtest 用法，大多数我也不知道有什么用~</p>
<h2 id="前文的一些补充"><a href="#前文的一些补充" class="headerlink" title="前文的一些补充"></a>前文的一些补充</h2><h3 id="谓词断言"><a href="#谓词断言" class="headerlink" title="谓词断言"></a>谓词断言</h3><p>有时候我们在检查一个返回值为 bool 类型的函数时，希望能够输出更详细的信息，例如测试时传入的参数是什么，那么可以使用 gtest 提供的谓词断言</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="built_in">TEST</span>(Test, MyTest) &#123;</span><br><span class="line">    <span class="built_in">EXPECT_PRED3</span>(func, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.pic/gtest-pred.png"></p>
<p>谓词断言输入函数和参数，gtest会通过函数返回的 bool 值输出参数信息。</p>
<ul>
<li>EXPECT_PRED1(pred, val1)</li>
<li>EXPECT_PRED2(pred, val1, val2)</li>
<li>…</li>
</ul>
<p>其中 pred 是函数名，val 是参数：</p>
<blockquote>
<p>最多只支持 PRED5，即五个入参的函数，不过可以魔改 gtest 源码来提高上限。</p>
</blockquote>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>可以使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::testing::<span class="built_in">StaticAssertTypeEq</span>&lt;T1, T2&gt;();</span><br></pre></td></tr></table></figure>

<p>来对两个类型进行断言，暂时还想不到什么测试场景会用到这个函数？</p>
<h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><p>GTEST_SKIP 宏用于跳过当前测试用例，嗯，很迷。</p>
<h2 id="死亡测试"><a href="#死亡测试" class="headerlink" title="死亡测试"></a>死亡测试</h2><p>死亡测试用于验证程序在预期崩溃场景下是否会正确中止，常用于验证致命错误处理逻辑的健壮性。gtest 的死亡测试仅针对用户无法处理的错误，可以被用户捕获的异常不包括在内（异常可以用 *_THROW 断言）。</p>
<p>死亡测试通过 *_DEATH 或 *_EXIT 宏来实现，gtest 会为每个死亡测试派生独立的子进程，避免主测试进程崩溃。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EXPECT_DEATH</span>(statement, regex);</span><br><span class="line"><span class="built_in">EXPECT_EXIT</span>(statement, predicate, regex);</span><br></pre></td></tr></table></figure>

<ul>
<li>regex 是一个正则表达式，用于匹配崩溃时 stderr 输出的错误信息。</li>
<li>predicate 接受一个谓词表达式，只有当表达式匹配时，死亡测试才通过，gtest 提供了一些常用的 predicate：<ul>
<li>testing::KilledBySignal(signal_number)：测试程序是否被信号 signal_number 杀死</li>
<li>testing::ExitedWithCode(exit_code)：测试程序是否以 exit_code 退出</li>
</ul>
</li>
</ul>
<p>举例函数 foo 在输入非法参数的情况下会导致程序会出现段错误而崩溃：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EXPECT_EXIT</span>(<span class="built_in">foo</span>(<span class="literal">nullptr</span>), testing::<span class="built_in">KilledBySignal</span>(SIGSEGV), <span class="string">&quot;.*&quot;</span>);  <span class="comment">// .* 匹配任意错误信息</span></span><br></pre></td></tr></table></figure>

<p>死亡测试还有一个目的在于，可以提前告知你的用户不要传入一些会导致程序崩溃的参数，虽然也可以在文档注明，可能也很少人会留意单元测试用例吧。</p>
<h2 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h2><h2 id="gmock"><a href="#gmock" class="headerlink" title="gmock"></a>gmock</h2><p>gmock 用于模拟复杂对象的交互逻辑，用于实现我们俗称打桩的功能，我们先来看比较基础的用法：</p>
<p>假设我们有一个交易处理模块，依赖于一个支付模块，这个支付模块有可能是支付宝、微信或者其他什么东西，无论如何，我们只是测试这个交易处理模块的功能，使用什么交付模块并不重要。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentGateway</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Charge</span><span class="params">(<span class="type">double</span> amount)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentProcessor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PaymentProcessor</span>(PaymentGateway *gateway)</span><br><span class="line">		: _gateway(gateway) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">PorcessPayment</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _gateway-&gt;<span class="built_in">Charge</span>(amount);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	PaymentGateway *_gateway;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时也为了避免发生真实交易，我们会使用 gmock 对交付模块进行打桩（当然你也可以自己继承并实现一个支付模块，来完成对交易处理模块的测试）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MockPaymentGateway</span> : <span class="keyword">public</span> PaymentGateway &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MOCK_METHOD</span>(<span class="type">bool</span>, Charge, (<span class="type">double</span> amount), (<span class="keyword">override</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(PaymentTest, CHargeSucceeds) &#123;</span><br><span class="line">	MockPaymentGateway mock;</span><br><span class="line">	<span class="built_in">EXPECT_CALL</span>(mock, <span class="built_in">Charge</span>(<span class="number">100.0</span>)).<span class="built_in">WillOnce</span>(<span class="built_in">Return</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">	<span class="function">PaymentProcessor <span class="title">processor</span><span class="params">(&amp;mock)</span></span>;</span><br><span class="line">	<span class="built_in">ASSERT_TRUE</span>(processor.<span class="built_in">Processpayment</span>(<span class="number">100.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--
这里我们定义了一个继承自交付模块的 mock 类，并使用 MOCK_METHOD 宏实现 Charge 了虚函数，在测试用例中我们使用 EXPECT_CALL 来声明 mock 对象的 Charge 方法在后续会被调用一次，且返回 true，而实际上 processor 对象确实会在 Processpayment 方法中调用一次 mock 的 Charge 方法。

EXPECT_CALL 既是声明又是隐式断言，除了可以用来设置函数的行为（如返回值、异常等），还可以用来设置函数的预期行为（如被调用次数、传入参数），EXPECT_CALL 会在其退出作用域后对预期行为进行断言。

上述的案例是通过在待测代码中引入带有 gmock 定义方法的派生类，来实现打桩的，如果依赖的接口的所属类并不是虚类，要如何实现呢？

gmock 的功能依赖于多态，无论是指针和引用还是模板，都可以在原有的代码上引入带有 gmock 定义方法的类，可是如果被测代码没有考虑拓展性，依赖于对象的变量？那么还可以使用适配器模式来实现。
-->
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/28/c++/gtest%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/28/c++/gtest%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">gtest入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-04-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-28T00:00:00+00:00">2025-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gtest入门"><a href="#gtest入门" class="headerlink" title="gtest入门"></a>gtest入门</h1><p>gtest（google test） 是一个由 Google 开发的开源的 C++ 测试框架，它支持跨平台（Linux、Windows、MacOS 等）测试，并提供从单元测试到接口测试的多层级验证能力。</p>
<p>github：<a target="_blank" rel="noopener" href="https://github.com/google/googletest">https://github.com/google/googletest</a></p>
<p>一个好的测试应该是怎样的？这是来自 google 测试开发团队给出的答案：</p>
<ul>
<li>测试用例应该是独立的和可复现的，彼此之间不会相互影响</li>
<li>测试用例应该具有组织性，并且可以被测试代码的模块化设计</li>
<li>测试用例应具备可移植性和复用性，而不是特定于平台实现的</li>
<li>测试失败时应反馈详细的失败信息，例如失败时的上下文，并且一次性能捕获多个错误</li>
<li>测试框架应可以自动管理所有的测试用例，而无需使用者手动注册用例、管理依赖</li>
<li>测试用例对共享资源初始化成本应最小化，以达到最大化测试效率</li>
</ul>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>从 gtest 源码编译后会包含四个静态库：</p>
<p><img src="/.pic/gtest-library.png"></p>
<p>其中 gmock 用于桩函数测试，gtest 用于单元测试。gtest 贴心的为我们准备了 _main 后缀的静态库，其内部实现是一个 main 函数，当我们不想自己写 main 函数的时候，我们就可以链接这个静态库，main 函数会为我们执行所有的测试用例。</p>
<ul>
<li>编写一个简单的测试工程</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(Test, MyTest) &#123;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span> + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gtest_main 的内部实现等价于下面的 main 函数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 CMake 中添加 gtest 库依赖</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(MyTest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检索 gtest 库路径 </span></span><br><span class="line"><span class="keyword">find_package</span>(GTest REQUIRED)    </span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(MyTest main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 gtest 库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyTest</span><br><span class="line">    PRIVATE gtest)              </span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    RUNTIME DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>运行测试工程</li>
</ul>
<!-- 补图 -->

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>在 gtest 框架中我们可以使用 TEST 宏定义一个测试用例，并通过两个输入参数来为这个测试用例命名，它还包含一个不需要返回值的函数体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(test_case_name, test_name) &#123;</span><br><span class="line">    <span class="comment">// No need to return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试用例命名没有严格要求，但需要保证 test_case_name 和 test_name 组合的唯一性。通常我们会将 test_case_name 命名为模块名，test_name 用于描述测试的功能。</p>
</blockquote>
<p>有了测试用例，怎么测试呢？</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>gtest 框架中主要使用断言来判断代码运行的结果是否符合预期，并非 cassert 里的断言，而是 gtest 提供的两种类型的宏函数，分别以 EXPECT 开头和 ASSERT 开头：</p>
<ul>
<li>EXPECT_*(…)：该断言失败时，程序会记录失败信息并继续往下执行</li>
<li>ASSERT_*(…)：该断言失败时，程序会记录失败信息并跳过当前测试用例，如果你认为失败时继续往下执行没有意义，那么这种断言比较合适</li>
</ul>
<blockquote>
<p>失败信息包括源文件和行号位置，以及期望值和实际值等信息。</p>
</blockquote>
<p>嗯，gtest 最简单的用法就是在测试用例中写断言，来进行单元测试。例如下面我们测试一个阶乘函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Factorial</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(TestFactorial, HandlesZeroInput) &#123;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(TestFactorial, HandlesPositiveInput) &#123;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span>, <span class="built_in">Factorial</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="number">3</span>, <span class="built_in">Factorial</span>(<span class="number">6</span>));</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="number">8</span>, <span class="built_in">Factorial</span>(<span class="number">40320</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gtest 提供了丰富断言函数，均包含 EXPECT 和 ASSERT 版本，以支持不同场景，以 EXPECT 为例：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值检查</td>
<td>EXPECT_TRUE(condition) <br> EXPECT_FALSE(condition)</td>
</tr>
<tr>
<td>二元比较函数</td>
<td>EXPECT_EQ(val1, val2)：val1 &#x3D;&#x3D; val2 <br> EXPECT_NE(val1, val2)：val1 !&#x3D; val2 <br> EXPECT_LT(val1, val2)：val1 &lt; val2 <br> EXPECT_LE(val1, val2)：val1 &lt;&#x3D; val2 <br> EXPECT_GT(val1, val2)：val1 &gt; val2 <br> EXPECT_GE(val1, val2)：val1 &gt;&#x3D; val2</td>
</tr>
<tr>
<td>字符串检查</td>
<td>EXPECT_STREQ(str1, str2)：str1 &#x3D;&#x3D; str2 <br> EXPECT_STRNE(str1, str2)：str1 !&#x3D; str2 <br> EXPECT_STRCASEEQ(str1, str2)：str1 &#x3D;&#x3D; str2（忽略大小写） <br> EXPECT_STRCASENE(str1, str2)：str1 !&#x3D; str2（忽略大小写）</td>
</tr>
<tr>
<td>浮点型检查</td>
<td>EXPECT_FLOAT_EQ(expected, actual) <br>  EXPECT_DOUBLE_EQ(expected, actual) <br> EXPECT_NEAR(val1, val2, abs_error)：对相近的两个数比较</td>
</tr>
<tr>
<td>异常检查</td>
<td>EXPECT_THROW(statement, exception_type)：指定异常 <br> EXPECT_ANY_THROW(statement)：任意异常 <br> EXPECT_NO_THROW(statement)：无异常</td>
</tr>
<tr>
<td>显示成功或失败</td>
<td>SUCCEED() <br> ADD_FAILURE()：失败 <br> FAIL()：失败，但不继续往下执行</td>
</tr>
</tbody></table>
<p>断言函数还支持左移运算符来追加自定义补充信息，不过这些信息只有在断言失败时才会输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EXPECT_TRUE</span>(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;damn, it failed&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="测试夹具"><a href="#测试夹具" class="headerlink" title="测试夹具"></a>测试夹具</h3><p>如果你发现自己写的几个测试用例中都需要执行一段相同且大量的初始化代码，那么可以试试使用测试夹具，它旨在于减少重复的代码。</p>
<p>定义一个测试夹具需要使用到 TEST_F 宏，它接受两个参数： test_fixture 和 test_name，其中 test_fixture 是我们自定义的测试夹具类，它继承自 testing::Test 类，并重载了 SetUp() 和 TearDown() 方法。</p>
<p>以测试 std::queue 为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QueueTester</span> : <span class="keyword">public</span> testing::Test </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;SetUp&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        q_.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        q_.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">        q_.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;TearDown&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_F</span>(QueueTester, Works) &#123;</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(q_.<span class="built_in">size</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(q_.<span class="built_in">front</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要重复使用的数据可以定义为 protected 成员变量，这样在测试用例中可以直接访问测试夹具中的成员变量。</p>
<p>SetUp 和 TearDown 是两个回调函数，在执行我们的测试用例之前，gtest 框架会先调用我们重载的 SetUp 方法，执行完测试用例之后，会调用 TearDown 方法。</p>
<blockquote>
<p>SetUp 和 TearDown 可以用于做一些初始化和清理的工作，虽然感觉构造函数和析构函数也一样能完成。</p>
</blockquote>
<h3 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h3><p>TEST 宏和 TEST_F 宏都会隐式地将测试用例注册到 gtest 框架中，和其他测试框架不同，不需要手动注册，只需要执行 RUN_ALL_TESTS 方法，即可运行所有已注册的测试用例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，你已经掌握了 gtest 的基本用法，开始做打杂牛马吧~</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/01/c++/call_once/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/01/c++/call_once/" class="post-title-link" itemprop="url">std::call_once</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-01T00:00:00+00:00">2024-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="std-call-once"><a href="#std-call-once" class="headerlink" title="std::call_once"></a>std::call_once</h1><p>C++ 11 的标准库引入了一个新的模板函数 std::call_once：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>它确保准确执行一次可调用 (Callable) 对象 f ，即使同时有多个线程调用。本文不讨论 call_once 的使用方法，主要研究并记录一下它是如何实现的。</p>
<p>根据 cppreference 的提示，call_once 通过传入的 once_flag 对象来判断函数对象是否执行过，因此实际上可以通过换一个新的 once_flag 实例来让函数对象再执行一次。</p>
<p>下面以 Linux 为例，来看看 call_once 的实现原理。</p>
<h2 id="std-call-once-的源码实现"><a href="#std-call-once-的源码实现" class="headerlink" title="std::call_once 的源码实现"></a>std::call_once 的源码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __once_proxy(<span class="type">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(once_flag&amp; once, Callable&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> callable = [&amp;] &#123;</span><br><span class="line">        std::<span class="built_in">invoke</span>(std::forward&lt;Callable&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">once_flag::_Prepare_execution <span class="title">exec</span><span class="params">(callable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> e = __gthread_once(&amp;once._M_once, &amp;__once_proxy))</span><br><span class="line">        __throw_system_error(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 call_once 函数中使用 lambada 表达式创建了一个闭包，并将其作为构造 Prepare_execution 对象的入参，然后调用了 __gthread_once，如果调用失败则会抛出一个 system_error 异常。</p>
<p>这里的 __gthread_once 是什么呢？Linux 环境下它是 pthread_once 的封装，它输入的正是 pthread_once_t 对象的地址和函数指针，感兴趣的同学可以了解一下 pthread_once 的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int pthread_once(pthread_once_t *once_control, void (*init_routine) (void));</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __gthread_active_p (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __gthread_once (<span class="type">__gthread_once_t</span> *__once, <span class="built_in">void</span> (*__func) (<span class="type">void</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__gthread_active_p ())</span><br><span class="line">        <span class="keyword">return</span> __gthrw_(pthread_once) (__once, __func);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我有点好奇 __once_proxy 是怎么调用我们传入的函数的，我们接着往下看。</p>
<h2 id="std-once-flag-的源码实现"><a href="#std-once-flag-的源码实现" class="headerlink" title="std::once_flag 的源码实现"></a>std::once_flag 的源码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">once_flag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">once_flag</span><span class="params">()</span> noexpect </span>= <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">once_flag</span>(<span class="type">const</span> once_flag &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    once_flag &amp;<span class="keyword">operator</span>=(<span class="type">const</span> once_flag &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">__gthread_once_t</span> _M_once = __GTHREAD_ONCE_INIT;     <span class="comment">// 初始状态表示未调用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Prepare_execution</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">friend</span> <span class="type">void</span> <span class="title">call_once</span><span class="params">(once_flag&amp; once, Callable&amp;&amp; f, Args&amp;&amp;... args)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到 once_flag 的实现还是比较简单，它包含一个 __gthread_once_t（pthread_once_t） 类型的成员变量 _M_once，并声明 call_once 为友元函数，这样 call_once 就可以直接取得其中的句柄 _M_once。</p>
<p>我们前面看到 call_once 的函数体中有构造 once_flag 的 _Prepare_execution 对象，这是其内部实现（这一块可能会有一些差异，其他平台的实现可能是在析构函数直接调用传入的函数对象）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> __thread <span class="type">void</span>* __once_callable;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> __thread <span class="title">void</span> <span class="params">(*__once_call)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">once_flag</span>::_Prepare_execution</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span><br><span class="line">    <span class="keyword">explicit</span> _Prepare_execution(Callable&amp; callable)</span><br><span class="line">    &#123;</span><br><span class="line">        once_callable = std::<span class="built_in">addressof</span>(callable);</span><br><span class="line">        once_call = [] &#123;</span><br><span class="line">            (*<span class="built_in">static_cast</span>&lt;Callable *&gt;(once_callable))();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~_Prepare_execution()</span><br><span class="line">    &#123;</span><br><span class="line">        once_callable = <span class="literal">nullptr</span>;</span><br><span class="line">        once_call = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _Prepare_execution(<span class="type">const</span> _Prepare_execution&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    _Prepare_execution &amp;<span class="keyword">operator</span>=(<span class="type">const</span> _Prepare_execution&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里可能会觉得一脸懵逼，这就没啦？谁去调用 once_call 啊？而且 __once_proxy 也跳转不进去。</p>
<p>我猜测应该是在哪个标准库的源文件里，最终在 libstdc++ 的源码找到了其实现（libstdc++-v3&#x2F;src&#x2F;c++11&#x2F;mutex.cc）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> __once_proxy()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The caller stored a function pointer in __once_call. If it requires</span></span><br><span class="line">    <span class="comment">// any state, it gets it from __once_callable.</span></span><br><span class="line">    __once_call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>朴实无华地调用了 __once_call，可是这样不会有线程安全的问题吗？</p>
<blockquote>
<p>__once_call、__once_callable 声明前的 __thread 是 C++11 前特有的 TLS（Thread Local State）声明方式，等效于 thread_local</p>
</blockquote>
<h2 id="pthread-once-的实现"><a href="#pthread-once-的实现" class="headerlink" title="pthread_once 的实现"></a>pthread_once 的实现</h2><p>感觉看了个寂寞，毕竟核心实现还是依赖于 pthread_once，那还是看看 pthread_once 是怎么实现的吧，获取源码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://https.git.savannah.gnu.org/git/hurd/libpthread.git</span><br></pre></td></tr></table></figure>

<p>首先是 pthread_once_t 的定义（sysdeps\pthread\bits\types\struct___pthread_once.h）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">pthread_once</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> __run;</span><br><span class="line">    <span class="type">__pthread_spinlock_t</span> __lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它由一个自选锁和一个标志位组成，这个标志位猜测是用于检测是否已经执行过。然后是 pthread_once 函数的实现（sysdeps&#x2F;generic&#x2F;pt-once.c）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __pthread_once (<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine) (<span class="type">void</span>))</span><br><span class="line">&#123;</span><br><span class="line">    atomic_full_barrier ();</span><br><span class="line">    <span class="keyword">if</span> (once_control-&gt;__run == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __pthread_spin_lock (&amp;once_control-&gt;__lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (once_control-&gt;__run == <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	        init_routine ();</span><br><span class="line">	        atomic_full_barrier ();</span><br><span class="line">	        once_control-&gt;__run = <span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">        __pthread_spin_unlock (&amp;once_control-&gt;__lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">strong_alias (__pthread_once, pthread_once);</span><br></pre></td></tr></table></figure>

<p>一个很经典的 DCLP（Double-Checked Locking Pattern）实现，atomic_full_barrier 用于确保原子操作的顺序性，配合自选锁使得对程序性能的影响达到了更小。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/01/c++/%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/01/c++/%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="post-title-link" itemprop="url">迭代器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-01 00:00:00" itemprop="dateCreated datePublished" datetime="2023-06-01T00:00:00+00:00">2023-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是一种用于遍历容器的工具，提供了一种通用的方式用于访问容器，使得操作容器的算法不需要关注容器的结构，作为容器和算法的粘合器，在泛型编程中起到了很大的作用。</p>
<p>迭代器就概念上有五种类型：</p>
<ul>
<li>输入迭代器，对容器的操作是只读的，对迭代器解引用将返回 const 类型的元素，仅提供 ++，*，&#x3D;&#x3D;，!&#x3D; 操作</li>
<li>输出迭代器，对容器的操作是只写的，仅提供 ++，* 操作</li>
<li>前向迭代器，对容器的操作是读写，提供输入迭代器和输出迭代器的所有操作</li>
<li>双向迭代器，支持前向和后向移动（++，–）</li>
<li>随机访问迭代器，支持 +、-、[]、比较运算符等操作</li>
</ul>
<p>linux 下提供了一些迭代器的标签来表示迭代去的类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct input_iterator_tag &#123; &#125;;</span><br><span class="line"></span><br><span class="line">///  Marking output iterators.</span><br><span class="line">struct output_iterator_tag &#123; &#125;;</span><br><span class="line"></span><br><span class="line">/// Forward iterators support a superset of input iterator operations.</span><br><span class="line">struct forward_iterator_tag : public input_iterator_tag &#123; &#125;;</span><br><span class="line"></span><br><span class="line">/// Bidirectional iterators support a superset of forward iterator</span><br><span class="line">/// operations.</span><br><span class="line">struct bidirectional_iterator_tag : public forward_iterator_tag &#123; &#125;;</span><br><span class="line"></span><br><span class="line">/// Random-access iterators support a superset of bidirectional</span><br><span class="line">/// iterator operations.</span><br><span class="line">struct random_access_iterator_tag : public bidirectional_iterator_tag &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>定义一个 iterator 需要提供下面几个属性，也可以使用 std::iterator_traits<T> 提取 T 迭代器的属性：</p>
<ul>
<li>iterator_category，迭代器的类型，就是上面的五个 tag 之一</li>
<li>value_type，一般就是容器的元素类型</li>
<li>difference_type，</li>
<li>pointer，指针</li>
<li>reference，引用</li>
</ul>
<p>在 C++ 17 之前也可以选择通过继承 std::iterator 来实现自己的迭代器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Category, typename _Tp, typename _Distance = ptrdiff_t,</span><br><span class="line">       typename _Pointer = _Tp*, typename _Reference = _Tp&amp;&gt;</span><br><span class="line">struct iterator</span><br><span class="line">&#123;</span><br><span class="line">    /// One of the @<span class="built_in">link</span> iterator_tags tag types@endlink.</span><br><span class="line">    typedef _Category  iterator_category;</span><br><span class="line">    /// The <span class="built_in">type</span> <span class="string">&quot;pointed to&quot;</span> by the iterator.</span><br><span class="line">    typedef _Tp        value_type;</span><br><span class="line">    /// Distance between iterators is represented as this <span class="built_in">type</span>.</span><br><span class="line">    typedef _Distance  difference_type;</span><br><span class="line">    /// This <span class="built_in">type</span> represents a pointer-to-value_type.</span><br><span class="line">    typedef _Pointer   pointer;</span><br><span class="line">    /// This <span class="built_in">type</span> represents a reference-to-value_type.</span><br><span class="line">    typedef _Reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于连续存储结构的容器类型，迭代器的实现可以是指针。也许你会很好奇指针的 iterator_category 是什么，虽然原生指针本身没有显示定义 iterator_category，但 c++ 标准库提供了特化版本，可以看到指针是随机访问迭代器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp&gt;</span><br><span class="line">struct iterator_traits&lt;_Tp*&gt;</span><br><span class="line">&#123;</span><br><span class="line">  typedef random_access_iterator_tag iterator_category;</span><br><span class="line">  typedef _Tp                         value_type;</span><br><span class="line">  typedef ptrdiff_t                   difference_type;</span><br><span class="line">  typedef _Tp*                        pointer;</span><br><span class="line">  typedef _Tp&amp;                        reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这也就是为什么 array、vector 这类容器的迭代器类型为 random_access_iterator_tag</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/31/c++/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/31/c++/%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">模板编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-31 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-31T00:00:00+00:00">2023-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h1><p>模板类的代码不直接参与编译，而是由编译器在编译时根据模板参数来生成代码，这种过程我们称之为模板实例化</p>
<h2 id="模板实例化的过程"><a href="#模板实例化的过程" class="headerlink" title="模板实例化的过程"></a>模板实例化的过程</h2><p>在代码中使用模板类构造对象或调用模板函数时，编译器会根据模板参数的实参来实例化模板类或模板函数，这种方式我们称之为隐式实例化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass&lt;<span class="type">int</span>&gt; obj;   <span class="comment">// 编译器根据模板参数 int 生成 Wrapper&lt;int&gt; 类型</span></span><br><span class="line">    <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 生成函数 add&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，还有显示实例化。在c++标准库的头文件可以遇到很多模板特化的模板类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;&#125;;  <span class="comment">// 模板特化</span></span><br></pre></td></tr></table></figure>

<p>如果没有显示指定模板参数，编译器会根据上下文（例如函数调用时传入的参数类型）推导出模板参数，例如上文的模板函数 add </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 类型推导</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化模板类时，编译器将模板类的<strong>每个成员函数和对象</strong>都根据给定的类型进行绑定，生成与特定类型相关的代码，不同的类型的代码是相互独立的</p>
<h2 id="类型萃取"><a href="#类型萃取" class="headerlink" title="类型萃取"></a>类型萃取</h2><p>简单来讲就是在编译期间对类型进行检查，判断类型是否满足某个条件，以便于我们做出决策（编译失败或其他），否则代码有可能在运行过程中出现未定义行为</p>
<p>下图是一个模板封装类，在模板参数不支持默认构造时，会报 no type named ‘type’ in ‘struct std::enable_if&lt;false, void&gt;’ </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> std::enable_if&lt;std::is_default_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Wrapper</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>std::enable_if 是一个模板，它接受两个参数，第一个参数是一个布尔值，第二个参数是模板参数的类型，如果第一个参数为 true，则 std::enable_if 会定义一个和第二个参数相同类型的 type 成员，反之不会</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span>, <span class="keyword">typename</span> _Tp = <span class="type">void</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> enable_if</span><br><span class="line">    &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">enable_if</span>&lt;<span class="literal">true</span>, _Tp&gt;</span><br><span class="line">    &#123; <span class="keyword">typedef</span> _Tp type; &#125;;</span><br></pre></td></tr></table></figure>

<p>通过这样的方式，我们可以限制模板参数的类型，当传入不符合的类型时，编译器会报错，当然这个用例更推荐使用比较直观的静态断言去实现</p>
<h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>有时候当用户传入的类型不合法时，我们也不能一棒子打死，在复杂一点的模板编程中，往往会实现多个模板重载，以适配不同的输入类型，而这离不开 C++ 的 SFINAE 机制</p>
<p>SFINAE（Substitution Failure Is Not An Error）顾名思义，就是当进行模板参数替换时，如果遇到了不合法的类型或条件时，编译器不会报错而是尝试其他可行的模板重载</p>
<p>这里有一个关键点是，一定要有其他的重载函数，否则编译器还是会报错</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::<span class="function">type </span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有 SFINAE 机制，上述的代码在实例化 int 版本的 print 时会报错，而如果没有第二个重载函数，编译器同样也会报错</p>
<h2 id="“-nullptr”和“typename-typename”是什么"><a href="#“-nullptr”和“typename-typename”是什么" class="headerlink" title="“* &#x3D; nullptr”和“typename &#x3D; typename”是什么?"></a>“* &#x3D; nullptr”和“typename &#x3D; typename”是什么?</h2><p>模板参数可以接收一个类型，也可以接收一个值，当进行模板参数替换时，编译器需要知道模板参数的具体类型或值，以下面这个模板为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> B&gt;</span><br></pre></td></tr></table></figure>

<p>编译器需要知道 T 的具体类型，同样也需要知道B的具体值，否则模板参数就是无效的，编译器会报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, </span><br><span class="line">              <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_move_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">Wrapper</span>(T &amp;&amp;value) <span class="keyword">noexcept</span></span><br></pre></td></tr></table></figure>

<p>typename type 会被翻译成具体的类型名，因此这里可以理解为当T支持移动构造时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, </span><br><span class="line">              <span class="keyword">typename</span> U = <span class="type">void</span>&gt;</span><br></pre></td></tr></table></figure>

<p>模板的参数名是可以缺省的，因此 “typename name &#x3D; typename” 可以被简写成 “typename &#x3D; typename”，“typename *name &#x3D; nullptr”被简写成了“typename * &#x3D; nullptr”</p>
<h2 id="为什么需要-“U-T”"><a href="#为什么需要-“U-T”" class="headerlink" title="为什么需要 “U &#x3D; T”"></a>为什么需要 “U &#x3D; T”</h2><p>如果我们按照如下实现一个模板类，并传入一个不支持拷贝构造的模板参数，那么无论如何，编译器都不会编译通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_default_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="built_in">Wrapper</span>() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">Wrapper</span>(T <span class="type">const</span> &amp;value) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_move_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">Wrapper</span>(T &amp;&amp;value) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">value_</span>(std::<span class="built_in">move</span>(value)) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    T &amp;<span class="built_in">value</span>() &amp; <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="type">const</span> T &amp;<span class="built_in">value</span>() <span class="type">const</span> &amp; <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_move_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    T &amp;&amp;<span class="built_in">value</span>() &amp;&amp; <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(value_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器在实例化一个模板类时，会首先替换类的模板参数，此处的 T 作为类的模板参数会被翻译成具体的类型，而不是一个函数的模板参数，因此编译器会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">late &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_default_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="built_in">Wrapper</span>() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">Wrapper</span>(T <span class="type">const</span> &amp;value) <span class="keyword">noexcept</span> </span><br><span class="line">        : <span class="built_in">value_</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_move_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">Wrapper</span>(T &amp;&amp;value) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">value_</span>(std::<span class="built_in">move</span>(value)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    T &amp;<span class="built_in">value</span>() &amp; <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_copy_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    <span class="type">const</span> T &amp;<span class="built_in">value</span>() <span class="type">const</span> &amp; <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;std::is_move_constructible&lt;T&gt;::value&gt;::type&gt;</span><br><span class="line">    T &amp;&amp;<span class="built_in">value</span>() &amp;&amp; <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(value_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而如果我们使用 U &#x3D; T 作为函数的默认模板，我们为这个函数定义了一个模板参数 U，那么编译器会认为这个函数是是一个模板函数，模板函数只有在被调用的时候才会被实例化，通过使用 U &#x3D; T 的方式，我们也延迟了 SFINAE 的检查。没有被调用的函数，当然不会编译报错</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/30/c++/%E5%AD%98%E5%82%A8%E7%B1%BB%E8%AF%B4%E6%98%8E%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/30/c++/%E5%AD%98%E5%82%A8%E7%B1%BB%E8%AF%B4%E6%98%8E%E7%AC%A6/" class="post-title-link" itemprop="url">存储类说明符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-30 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-30T00:00:00+00:00">2023-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="存储类说明符"><a href="#存储类说明符" class="headerlink" title="存储类说明符"></a>存储类说明符</h1><p>存储类说明符（storage class specifiers）是 C++ 中用于指定变量或函数的存储期和链接属性。</p>
<p>存储期即对象的生命周期，根据用于分配内存的方法，C++ 有以下几种存储期：</p>
<ul>
<li>自动存储期，随着代码块的结束而自动释放，一般指不带任何说明符的环境变量的存储期</li>
<li>静态存储期，跟随程序的生命周期的存储期，一般指函数体外或使用 static 声明的变量</li>
<li>动态存储期，位于堆内存，使用 new 和 delete 管理的变量</li>
<li>线程存储期（C++ 11 起），随着线程生命周期的存储期</li>
</ul>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>在 C++ 11 前，auto 用于声明一个变量为自动存储器的局部变量，但局部变量本就是自动存储器的，所以 auto 是多余的。于 C++ 11 之后，auto 的语义变为自动类型推导。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>register 声明一个变量时用于建议将变量存储在寄存器中以提升访问速度，而不是在内存中，这是 C++ 下的一个说明符。该说明符在 C++ 11 中被弃用：</p>
<ol>
<li>编译器会自动将合适的变量放入寄存器，无需程序员手动指定，人工指定可能还会干扰优化策略，导致性能下降</li>
<li>被 register 声明的变量无法取址，或者说无法取寄存器的地址，限制了某些场景的使用</li>
<li>register 只适用于基本数据类型，复杂类型无法装入寄存器，使用场景有限</li>
</ol>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>被 static 声明的变量处于静态存储器，生命周期持续到程序结束，同时会修改器链接属性：全局静态变量&#x2F;函数符号不会被外部可见</p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>用于将变量或函数声明为外部符号，在链接阶段使用其他文件中定义的符号或函数</p>
<h2 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h2><p>用于声明线程局部存储变量，每个线程都会拥有其独立的实例，线程之间不会相互干扰，作为无锁方案的一部分</p>
<p>在 Linux C 下可以使用 pthread_key_create、pthread_setspecific、pthread_getspecific、pthread_key_delete 来实现线程局部存储，以达到和 thread_local 一样的功能。</p>
<p>线程局部存储可能位于线程栈附近的专用 TLS 段。</p>
<p>只有用到 thread_local 修饰的变量的线程，才会创建副本。</p>
<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>允许类的成员变量在 const 成员函数中被修改</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/29/c++/gdb%E8%B0%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/29/c++/gdb%E8%B0%83%E8%AF%95/" class="post-title-link" itemprop="url">在 Linux 下使用 gdb 调试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-29T00:00:00+00:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="在-Linux-下使用-gdb-调试"><a href="#在-Linux-下使用-gdb-调试" class="headerlink" title="在 Linux 下使用 gdb 调试"></a>在 Linux 下使用 gdb 调试</h1><p>gdb 是 Unix 系统下源码级调试工具，用于查看程序在执行过程中的内部状态，或者在程序发生崩溃时可以查看崩溃在哪。gdb 通过将调试进程作为 gdb 的子进程，并接管待调试程序的所有信号，以达到调试的目的。</p>
<p>gdb 不仅限于 c++ 开发中的调试，作为 rust、go 等语言的开发者，同样也可以使用 gdb 进行调试。</p>
<p>gdb 的代码是开源的，我们可以从官网上自行下载源码编译并部署到我们自己的系统上，或使用包管理系统安装 gdb：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gdb</span><br></pre></td></tr></table></figure>

<p>源码包下载路径：<a target="_blank" rel="noopener" href="https://ftp.gnu.org/gnu/gdb/">https://ftp.gnu.org/gnu/gdb/</a></p>
<h2 id="gdb-的核心-ptrace"><a href="#gdb-的核心-ptrace" class="headerlink" title="gdb 的核心 ptrace"></a>gdb 的核心 ptrace</h2><p>ptrace（process trace）是一个系统调用，能够为一个进程提供观察和控制另一个进程的执行过程的能力，同时也提供检查和改变另一个进程的内存值以及相关注册信息的能力，被控制的进程称为 tracee，控制进程称为 tracer，tracer 会接管 tracee 的所有信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">void</span> *addr, <span class="type">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>request，要执行的操作类型<ul>
<li>PTRACE_TRACEME，将当前进程标记为被追踪的对象</li>
<li>PTRACE_ATTACH，将一个进程附加到另一个进程上进行调试跟踪</li>
<li>PTRACE_DETACH，从一个已经被附加和调试的进程上分离调试器</li>
<li>PTRACE_PEEKDATA，从目标进程中的内存读取数据</li>
<li>PTRACE_POKEDATA，从目标进程中的内存写入数据</li>
<li>PTRACE_GETREGS，从目标进程的寄存器中读取数据</li>
<li>PTRACE_SETREGS，向目标进程的寄存器中写入数据</li>
<li>PTRACE_CONT，继续执行目标进程</li>
</ul>
</li>
<li>pid，要追踪的目标进程 ID</li>
<li>addr，被监控的目标内存地址</li>
<li>data，读取或者要写入的数据</li>
</ul>
<h2 id="调试指南"><a href="#调试指南" class="headerlink" title="调试指南"></a>调试指南</h2><p>在调试前需要确保调试程序具备调试信息，例如为编译后的程序保留调试符号信息，例如在使用 gcc 编译时使用了 -g 选项，cmake 中可以使用下面任意一条语句：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-g)</span><br><span class="line"><span class="keyword">target_compile_options</span>(my_executable PRIVATE -g)</span><br></pre></td></tr></table></figure>

<p>同时建议关闭优化选项，否则可能会导致调试信息与源代码对应不上：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-O0)</span><br><span class="line"><span class="keyword">target_compile_options</span>(my_executable PRIVATE -O0)</span><br></pre></td></tr></table></figure>

<p>下面介绍几种 gdb 的常见调试方法：</p>
<h3 id="通过-gdb-启动进程调试"><a href="#通过-gdb-启动进程调试" class="headerlink" title="通过 gdb 启动进程调试"></a>通过 gdb 启动进程调试</h3><p>直接通过 gdb + &lt;可执行程序&gt; 来启动调试，这时 gdb 会调用 fork 来创建一个子进程：</p>
<ul>
<li>调用系统函数 ptrace + PTRACE_TRACEME，表示希望父进程对齐进行追踪</li>
<li>调用 exec 执行可执行程序，此时子进程会进入 TASK_TRACE 状态，父进程可以通过 ptrace 来控制子进程，观察子进程的执行状态</li>
</ul>
<h3 id="附加调试"><a href="#附加调试" class="headerlink" title="附加调试"></a>附加调试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb attach &lt;pid&gt;</span><br><span class="line">gdb -p &lt;pid&gt;        <span class="comment"># 还是这种方式好记    </span></span><br></pre></td></tr></table></figure>

<ul>
<li>此时 gdb 会调用 ptrace + PTRACE_ATTACH 来附加到目标进程，并将目标进程作为 gdb 的子进程</li>
<li>接着 gdb 发送 SIGSTOP 信号给调试进程，调试进程收到信号后会暂停进入 TASK_STOP 状态</li>
</ul>
<h3 id="coredump"><a href="#coredump" class="headerlink" title="coredump"></a>coredump</h3><p>在此之前先说明以下什么是 coredump 文件，它是一个在程序崩溃时记录进程当前状态的一个快照文件，它包含进程当前内存、寄存器、运行堆栈等信息。coredump 调试通常是我们在排查线上问题的主要手段。</p>
<h4 id="core-文件生成"><a href="#core-文件生成" class="headerlink" title="core 文件生成"></a>core 文件生成</h4><p>默认情况下程序崩溃不会产生 core 文件，那么如何生成 coredump 文件？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c   <span class="comment"># 查看 core 文件限制大小，如为 0 表示不会生成 core 文件</span></span><br><span class="line"><span class="built_in">ulimit</span> -a   <span class="comment"># 懒人法，会列出系统的所有限制，其中 core file size 代表 core 文件大小，0 表示不会生成</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited     <span class="comment"># 设置为 unlimited，表示产生 core 文件, 且不限制 core 文件大小</span></span><br></pre></td></tr></table></figure>

<p>上述指令会程序崩溃时在程序的工作目录生成 core 文件，在重启系统后失效，如需要永久生效，可以修改 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件，或扔 &#x2F;etc&#x2F;profile 里，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft core unlimited   <span class="comment"># 所有用户的软限制</span></span><br><span class="line">* hard core unlimited   <span class="comment"># 所有用户的硬限制</span></span><br></pre></td></tr></table></figure>

<p>如使用的是 systemd 系统，可以修改 &#x2F;etc&#x2F;systemd&#x2F;system.conf 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultLimitCORE=infinity</span><br></pre></td></tr></table></figure>

<p>如需要修改生成路径则需要修改 &#x2F;etc&#x2F;sysctl.conf 文件或使用 sysctl -w 设置，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernal.core_pattern = /tmp/core.%e.%p.%t        <span class="comment"># 指定 core 文件生成路径</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/tmp/core.%e.%p.%t&quot;</span> &gt; /proc/sys/kernel/core_pattern   <span class="comment"># 或者这种方式也行</span></span><br></pre></td></tr></table></figure>

<p>常见 pattern：</p>
<ul>
<li>%c core 文件大小</li>
<li>%e 可执行文件名</li>
<li>%g 进程组 ID</li>
<li>%h 主机名</li>
<li>%p 进程 ID</li>
<li>%s 进程状态</li>
<li>%t 时间戳</li>
<li>%u 用户名</li>
<li>%g 进程组 ID</li>
<li>%t 产生的时间</li>
<li>%u 用户名</li>
<li>%p 进程 ID</li>
<li>%s 所dump 的信号</li>
<li>%u ，%u用户id</li>
</ul>
<h2 id="常见调试命令"><a href="#常见调试命令" class="headerlink" title="常见调试命令"></a>常见调试命令</h2><ul>
<li>传递参数：set args …</li>
<li>运行：r（run）</li>
<li>开始调试？：start，停止在main，用于单步调试</li>
<li>下一步：n（next）</li>
<li>继续运行：c（continue）</li>
<li>detach：分离调试器</li>
</ul>
<p>如不记得某个命令的用法，可以使用 help &lt;具体的命令&gt; 来查看</p>
<h3 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h3><p>通过 break（b）指令我们可以添加一个断点，程序会在运行到断点处停下：</p>
<ul>
<li>break function，在函数的入口处添加一个断点</li>
<li>break line，在当前文件的行号处添加一个断点</li>
<li>break filename:line，在指定文件的行号处添加一个断点</li>
</ul>
<p>在上述操作的基础上将 break 改成 tbreak（tb）则会添加一个临时断点，只会触发一次</p>
<p>断点指令后可以添加条件表达式，例如：b func if xxx，表示在断点处满足条件才触发断点</p>
<p>可以通过 info b 指令查看所有断点，每个断点都有一个自己的编号，我们可以使用 delete <Num>、enable <Num>、disable <Num> 来对断点进行操作</p>
<p>.. image:: .&#x2F;pic&#x2F;20250304-110028.jpg</p>
<p>断点可以通过 save b filename 和 source filename 来将断点操作保存到指定的文件或从中读取</p>
<h3 id="显示代码"><a href="#显示代码" class="headerlink" title="显示代码"></a>显示代码</h3><p>使用 list（l）指令可以查看当前执行位置附近的代码，前提是开了 debug 模式，不然啥都看不见（）</p>
<p>和断点的操作指令类似，可以查看指定函数、行号附近的代码</p>
<p>list 每次执行都会打印上次打印后面的代码，也可以使用 l - ， l+ 来调整打印的位置</p>
<ul>
<li>list FIRST, LAST，指定打印行号范围</li>
<li>set listsize COUNT，设置每次打印的行数</li>
<li>show listsize，查看每次打印的行数</li>
</ul>
<h3 id="查看当前堆栈"><a href="#查看当前堆栈" class="headerlink" title="查看当前堆栈"></a>查看当前堆栈</h3><p>通过 backtrace（bt）来查看当前调用堆栈，可以很清晰的看到函数的调用关系，例如下面的函数调用栈；</p>
<p>.. image:: .&#x2F;pic&#x2F;20250304-104146.jpg</p>
<p>使用 frame &lt;堆栈编号&gt; 可以跳转到响应的堆栈（函数）处</p>
<p>使用 print（p） 指令可以打印一些信息，就像操作一个实际的变量一样：</p>
<ul>
<li>p var，打印变量 var 的值</li>
<li>p &amp;var，打印变量 var 的地址</li>
<li>p *var，打印指针 var 的内容</li>
<li>p strerror(errno)，甚至是调用函数打印其返回值</li>
</ul>
<p>使用 ptype（pt）查看一个变量的类型</p>
<p>watch 变量名或内存地址，当变量的值发生变化时，gdb 会在当前位置暂停，并打印变量的值，每个 watch 都有对应编号，可以像操作断点那样操作一个监控</p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><ul>
<li>step（s）单步执行，遇到函数是会进入函数体内部</li>
<li>next（n）单步执行，遇到函数不会进入函数体内部</li>
<li>finish，执行完当前函数</li>
<li>return，直接从当前函数返回，可以在指令后指定返回值</li>
<li>until（u），执行到指定行号</li>
</ul>
<h3 id="多线程调度"><a href="#多线程调度" class="headerlink" title="多线程调度"></a>多线程调度</h3><p>使用 info threads 可以查看所有线程，每个线程都会有一个 Id，我们可以使用 thread <Id> 切换到对应线程</p>
<p>那么在多线程调试环境下，如果正在调试当前的线程，那么其他线程表现如何？调度器锁用于控制其他线程的行为，他有下面几个模式：</p>
<ul>
<li>on，只有当前线程可以运行，其他线程暂停运行</li>
<li>off，没有锁定，任何线程都可以随时运行</li>
<li>step，当单步执行某一线程时（使用step、next）其他线程不会执行，当使用 continue、finish、return、until 时其他线程会继续运行</li>
<li>replay，默认模式，在重放模式下，其他线程会被暂停，正常执行期间，其他线程可以随时运行（重放模式后面会讲到）</li>
</ul>
<p>通过 show scheduler-locking 指令，我们可以查看当前的调度锁模式，使用 set scheduler-locking <mode> 来修改调度锁模式</p>
<p>重放是使用 replay 指令记录之前执行过的操作，使用 reverse-* 来反向执行的一种操作，暂时想不到什么使用场景，埋个坑</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/28/c++/const%E4%B8%8Econstexpr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/28/c++/const%E4%B8%8Econstexpr/" class="post-title-link" itemprop="url">const 与 constexpr</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-28 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-28T00:00:00+00:00">2023-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="const-与-constexpr"><a href="#const-与-constexpr" class="headerlink" title="const 与 constexpr"></a>const 与 constexpr</h1><p>constexpr 是 C++11 引入的新说明符，它和 const 具有相同的特性：</p>
<ul>
<li>都可以用于修饰变量，被修饰的变量不可修改</li>
<li>修饰函数的返回值时，表示返回值是常量</li>
</ul>
<p>不同点在于，constexpr 核心目标是将对象的计算转移到编译器，而不需要像 const 那样等到运行时，使程序运行速度更快、占用内存更少。下面是 constexpr 的一些应用场景：</p>
<h2 id="constexpr-变量"><a href="#constexpr-变量" class="headerlink" title="constexpr 变量"></a>constexpr 变量</h2><p>被 constexpr 修饰的变量，必须通过常量表达式初始化。</p>
<p>被 constexpr 修饰的静态成员变量允许直接在类内声明并初始化，而无需在类外定义。</p>
<h2 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a>constexpr 函数</h2><p>C++ 11 下，被 constexpr 修饰的函数，只能有一条 return 语句，且 return 语句的返回值必须是常量表达式。</p>
<p>C++ 14 下放宽了 constexpr 函数的能力，使其可以支持更复杂的逻辑，如 constexpr 函数可以支持创建局部变量、for、if 语句。</p>
<p>C++ 17 下 constexpr 可以被用于修饰 lambda 表达式，同时还可以用于编译器选择代码分支，以替代 SFINAE：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get_value</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_pointer_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *t;  <span class="comment">// 若 T 是指针类型，编译此分支</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;   <span class="comment">// 否则编译此分支</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="constexpr-成员函数"><a href="#constexpr-成员函数" class="headerlink" title="constexpr 成员函数"></a>constexpr 成员函数</h2><p>被修饰为 &#x3D; default 或 &#x3D; delete 的函数，可以被声明为 constexpr。</p>
<p>C++ 11 下，constexpr 构造函数的函数体必须为空，这意味着所有成员必须初始化，且只能通过初始化列表的方式初始化；C++ 14 后，允许函数体包含一些简单的运算。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/27/c++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/27/c++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">智能指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-27 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-27T00:00:00+00:00">2023-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="什么是智能指针？"><a href="#什么是智能指针？" class="headerlink" title="什么是智能指针？"></a>什么是智能指针？</h2><p>智能指针是用于帮助用户管理动态内存的模板类，通过利用 RAII 机制，确保对象在生命周期结束时自动释放内存，而不需要用户手动释放。</p>
<p>目前 C++11 有四种类型的智能指针：unique_ptr、shared_ptr、weak_ptr 和 auto_ptr。</p>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>auto_ptr 是 C++98 中的智能指针，由于它不支持托管资源的复制，在 C++11 中被弃用，在 C++17 中被删除，因此不建议使用。</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr 具有托管对象的独占所有权，它不允许被复制，只能通过移动语义来交换资源。适用于管理独占资源。</p>
<p>std::make_unique 是 c++ 14 引入的，用于创建 unique_ptr 对象。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr 的托管对象可以被多个 shared_ptr 共享，其内部维护了一个引用计数，每当发生 shared_ptr 的复制时，该引用计数会增加；当 shared_ptr 析构时该引用计数会减少；当引用计数为 0 时，托管资源会被释放。</p>
<p>shared_ptr 的引用计数操作是原子性的，即 shared_ptr 是线程安全的，但是 shared_ptr 所托管的对象不是线程安全的，如果多线程访问 shared_ptr 所托管的对象，需要外部同步。</p>
<p>当两个对象之间通过 shared_ptr 互相引用会造成引用计数永远不为 0 的情况，这意味着所托管的资源永远不会被释放，造成内存泄漏。为此，C++11 引入了 weak_ptr 来解决这个问题。</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr 是一种弱引用指针，它的复制和析构不会修改 shared_ptr 所维护的引用计数，也不会组织对象被销毁。</p>
<p>它提供了一些用于查询引用计数（use_count）和判断托管对象是否有效（expired）的方法，并能够获取托管对象的 shared_ptr，当 shared_ptr 所托管的对象被销毁时，将返回 nullptr。</p>
<h2 id="一个对象如何获取自身的-shared-ptr？"><a href="#一个对象如何获取自身的-shared-ptr？" class="headerlink" title="一个对象如何获取自身的 shared_ptr？"></a>一个对象如何获取自身的 shared_ptr？</h2><p>某个类内调用了一个需要传入 shared_ptr 的函数，我们需要如何获取自身的 shared_ptr？</p>
<p>首先，我们不能直接传入 this 指针，当这个类的对象被析构时，使用 this 指针构造的 shared_ptr 将会导致段错误。将自身作为 shared_ptr 传入给另一个类或函数使用，这是一种共享的场景，首先这个类必须是由 shared_ptr 管理的。</p>
<p>C++11 引入了 std::enable_shared_from_this，这个类包含了一个 weak_ptr，而上面所说的类只需要继承 enable_shared_from_this 即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt;    <span class="comment">// 必须公有继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">get_shared_this</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;MyClass&gt; obj = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(); <span class="comment">// 只有 shared_ptr 才可以使用 shared_from_this</span></span><br></pre></td></tr></table></figure>

<p>当通过 std::make_shared 或 shared_ptr 构造函数创建对象时，</p>
<h2 id="unique-ptr-和-shared-ptr-的删除器的设计差异？"><a href="#unique-ptr-和-shared-ptr-的删除器的设计差异？" class="headerlink" title="unique_ptr 和 shared_ptr 的删除器的设计差异？"></a>unique_ptr 和 shared_ptr 的删除器的设计差异？</h2><p>unique_ptr 和 shared_ptr 的构造函数都可以传入一个自定义 Deleter，尽管它们都提供了默认的实现。</p>
<p>unique_ptr 的删除器是模板参数的一部分，删除器的类型会直接影响 unique_ptr 的类型，在对象被析构时会调用删除器的 operator()，因此它可以是一个函数指针也可以是一个对象，根据删除器的大小可能会增加 unique_ptr 的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Deleter</span> = std::default_delete&lt;T&gt;</span><br><span class="line">&gt; <span class="keyword">class</span> unique_ptr;</span><br></pre></td></tr></table></figure>

<p>shared_ptr 的删除器是作为 shared_ptr 的成员变量，它其实是一个函数指针，在运行时存在微小的开销，但灵活性更高。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Deleter &gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">( std::<span class="type">nullptr_t</span> ptr, Deleter d )</span></span>;</span><br></pre></td></tr></table></figure>

<p>unique_ptr 删除器在编译时确定，而 shared_ptr 的删除器可以在运行时动态绑定。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/26/c++/%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Haopeng Wu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nano">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Nano">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/26/c++/%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">引用和指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-26 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-26T00:00:00+00:00">2023-05-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-17 14:47:12" itemprop="dateModified" datetime="2025-08-17T14:47:12+00:00">2025-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h1><p>引用是 C++ 中新增的一个概念，它相当于变量的别名，和被引用的变量共用同一块内存空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;     <span class="comment">// b 是 a 的引用</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure>

<h2 id="引用和指针的区别？"><a href="#引用和指针的区别？" class="headerlink" title="引用和指针的区别？"></a>引用和指针的区别？</h2><p>在谈论引用和指针的区别前，我们先看看它们的共同点：</p>
<ol>
<li>引用和指针都能够间接的访问变量</li>
<li>都支持多态</li>
<li>它们都指向一块内存，这在传参时可以避免拷贝</li>
</ol>
<p>不同点：</p>
<ol>
<li>指针是一个变量，该变量存储了另一个变量的地址，而引用是一个别名，它和被引用的变量共用同一块内存空间。</li>
<li>指针可以不初始化，或初始化为 nullptr；而引用由于不参与内存管理，因此他必须指向一个有效的对象。在作为参数传递时，引用不需要判空，因此比指针更安全。</li>
<li>指针在运行时可以改变指向的对象，而引用一旦初始化不能更改绑定的对象，引用更像是一个指针常量。</li>
<li>指针在访问所指向的对象时，需要在前面加“*”号解引用，引用直接使用引用名即可。</li>
<li>指针可以嵌套，即多级指针，而引用不支持多级。</li>
<li>使用场景的差异：指针一般用于变量的动态内存管理，引用一般用于函数参数传递、运算符重载或链式调用。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Haopeng Wu</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
